<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Location Simulator</title>
   
    <!-- Leaflet CSS  -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.8.0/dist/leaflet.css" integrity="sha512-hoalWLoI8r4UszCkZ5kL8vayOGVae1oxXe/2A4AO6J9+580uKHDO3JdHb7NzwwzK5xr/Fs0W40kiNHxM9vyTtQ==" crossorigin="" />

    <style>
        body {
            margin: 0;
            padding: 0;
        }

        #map {
            width: 100%;
            height: 97vh;
        }
    </style>

</head>

<body>
    <button id="backTo">Comeback to Area</button>
    <div id="map"></div>
</body>
</html>

<!-- Leaflet JS  -->
<script src="https://unpkg.com/leaflet@1.8.0/dist/leaflet.js" integrity="sha512-BB3hKbKWOc9Ez/TAwyWxNXeoV9c1v6FIeYiBieIWkpLjauysF18NzgR1MBNBXf8/KABdlkX68nAhlwcDFLGPCQ==" crossorigin=""></script>
<!-- PointInPolygon Plugin -->
<script src="https://rawgit.com/hayeswise/Leaflet.PointInPolygon/master/wise-leaflet-pip.js"></script>

<script>

    var startLocation = [41.05111255794263, 29.01896953582764], 
    //Start | Latitude 41.051994533247054  | 41.0540724388416  | Inside: 41.04916303115243
    //Start | Longitude 29.018325805664066 | 29.01448488235474 | Inside: 29.017210006713867

        map = L.map('map').setView([startLocation[0], startLocation[1]], 17),
        osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(map);

    // map.on('click', function(e) { 
    //    alert(e.latlng.lat + ", " + e.latlng.lng);
    // }); 

    if(!navigator.geolocation){ //Geolocation Support Control (Not necessary as we don't use geolocation for now)
        console.log("No Browser Support"); 
    } else {
        //Number of Users (Markers), Line Length, Rotation Speed for SetInterval (Milliseconds), Distance Setting, Polygon (Area)
        walk(10, 10, 100, 8000, drawArea());
    }
       
function walk(n, lineLength, intervalRate, dist, polygons){
    var polyline = L.polyline([[0, 0], [0, 0]], {color: 'rgba(255, 0, 0, 0.6)'}), //Polyline for Outside the Polygon
        innerPolyline = L.polyline([[0, 0], [0, 0]], {color: 'rgba(0, 0, 0, 0.6)'}), //Polyline for Inside the Polygon

        markers = [], //Markers
        coord = [[]], //Polyline Coordinates for Outside the Polygon
        inCoord = [[[[]]]], //Polyline Coordinates for Inside the Polygon
        inx = [], //Represent Indexes from "inCoord" | [i][0] Index1, Represent Polylines | [i][1] = Index2, Represent Polyline Points
        time = [], //Timers | [i][0] Represent Second | [i][1] Represent Minute | [i][2] Represent Hour

        control = false; //Marker - Polygon Contains Controller

    for(i = 0; i < n; i++){
        markers.push(L.marker([startLocation[0], startLocation[1]], {title: "User " + i}));
        markers[i].addTo(map);
        
        coord.push([[]]);
        inCoord.push([[[]]]);
        inx.push([0, 0]);
        time.push([0, 0, 0]);
    }coord.shift(); inCoord.shift();

    for(i = 0; i < n; i++){
        coord[i].shift();
        for(j = 0; j < (lineLength + 1); j++)
            coord[i].push([startLocation[0], startLocation[1]]);
    }
         
    setInterval(() => {
        for(i = 0; i < n; i++){
            control = isContain(polygons, i);
        
            markers[i].addTo(map);
            polyline.addTo(map);
            innerPolyline.addTo(map);
        
            for(j = 0; j < lineLength; j++)
                for(k = 0; k < 2; k++)
                    coord[i][j][k] = coord[i][j + 1][k];

            var latV = (Math.random()) / dist,
                lonV = (Math.random()) / dist,
            direction = Math.floor(Math.random() * 20);
            if(direction > 7) direction = Math.floor(Math.random() * 4); //Reduce the Chance of Going Straight
            switch(direction){
                case 0: coord[i][lineLength][0] += latV; coord[i][lineLength][1] += lonV; break; //Northeast
                case 1: coord[i][lineLength][0] -= latV; coord[i][lineLength][1] -= lonV; break; //Southwest
                case 2: coord[i][lineLength][0] += latV; coord[i][lineLength][1] -= lonV; break; //Northwest
                case 3: coord[i][lineLength][0] -= latV; coord[i][lineLength][1] += lonV; break; //Southeast
                case 4: coord[i][lineLength][0] += latV; break; //North
                case 5: coord[i][lineLength][0] -= latV; break; //South
                case 6: coord[i][lineLength][1] += lonV; break; //East
                case 7: coord[i][lineLength][1] -= lonV; break; //West
            }
        
            if(isContain(polygons, i)){ //Permanent Polyline
                inCoord[i][inx[i][0]][inx[i][1]] = ([coord[i][lineLength][0], coord[i][lineLength][1]]);
                inx[i][1]++;

                markers[i].setLatLng(inCoord[i][inx[i][0]][inCoord[i][inx[i][0]].length - 1]);
                innerPolyline.setLatLngs(inCoord);
            
            } else { //Temporary Polyline
                markers[i].setLatLng(coord[i][lineLength]);
                polyline.setLatLngs(coord);

            }
        
            if(control == false && isContain(polygons, i) == true){ //Entering the Polygon
            }
            if(control == true && isContain(polygons, i) == false){ //Going Out from Polygon
                if(!(time[i][0] == 0 && time[i][1] == 0 && time[i][2] == 0)) //Momentary In-Out Protection
                console.log("User " + i + "'s area time:.. " + time[i][2] + " Hour, " + time[i][1] + 
                " Minute, " + time[i][0] + " Second");
                
                time[i][0] = 0; time[i][1] = 0; time[i][2] = 0;

                inCoord[i].push([[]]);
                inx[i][0]++; inx[i][1] = 0;

            }
        
            markers[i].bindPopup("<b>Device Location</b><br/>Latitude: "+coord[i][lineLength][0]+
            "<br/> Longitude: "+coord[i][lineLength][1]+"");

        }
    }, intervalRate); 

    setInterval(() => { //Clock
        for(i = 0; i < n; i++){
            if(isContain(polygons, i)){
                time[i][0]++;
                if(time[i][0] == 59) { time[i][0] = 0; time[i][1] +=1; }
                if(time[i][1] == 59) { time[i][1] = 0; time[i][2] +=1; }
            }            
        }
    }, 1000);

    function isContain(polygons, i){
        for(j = 0; j < polygons.length; j++)
                if (polygons[j].contains(markers[i].getLatLng())) return true;

        return false;
    }
}  

function drawArea(){
    var polygonLatlngs = [[[41.04358197086135, 29.01344418525696], [41.04565262742985, 29.013347625732425], //Coordinates for Polygons
                           [41.04719720050334, 29.012607336044315], [41.047787635367726, 29.012124538421634],
                           [41.04862951629175, 29.012532234191898], [41.0495111033728, 29.012553691864017],
                           [41.050538258742634, 29.01273608207703], [41.052940283898614, 29.01472091674805],
                           [41.05148452154576, 29.01646971702576], [41.050125780953955, 29.018347263336185],
                           [41.04981035501779, 29.020053148269657], [41.04841113968484, 29.020621776580814],
                           [41.04758631648742, 29.021662473678592], [41.04601430734825, 29.018448291348626],
                           [41.045682684961676, 29.018480477856798]],

                          [[41.054474019045465, 29.0159547328949], [41.05448210633556, 29.015933275222782],
                           [41.05347118736744, 29.017789363861088], [41.05435038986155, 29.019044637680054],
                           [41.05347291133024, 29.01994585990906], [41.053448649084736, 29.020648598670963],
                           [41.05219913134572, 29.021292328834537], [41.05193628478723, 29.020847082138065],
                           [41.05183114586983, 29.020289182662967], [41.051554103257146, 29.020117521286014],
                           [41.05143683223414, 29.019613265991214], [41.05196325718982, 29.01951670646668],
                           [41.05315149130998, 29.018159508705143], [41.05338602703428, 29.017671346664432],
                           [41.053851052290966, 29.0162605047226], [41.054376481875295, 29.015809893608093]],

                          [[41.05112843069331, 29.023293256759647], [41.051156737643815, 29.024146199226383],
                           [41.050529938032184, 29.02424275875092], [41.05036876862615, 29.024339318275455],
                           [41.050400533497736, 29.023802876472477],
                           [41.05058655243598, 29.02375996112824], [41.05091006238022, 29.023615121841434],
                           [41.05089793078602, 29.023314714431763]]],
    polygons = [];
    for(i = 0; i < polygonLatlngs.length; i++){
        var polygon = new L.polygon(polygonLatlngs[i], {color: 'rgb(0, 200, 0)'});
        polygons.push(polygon);
        polygons[i].addTo(map);
    }

    return polygons;

}

    L.DomEvent.on(document.getElementById('backTo'),'click',(e)=>{ //Comeback to Area;
	    pauseAutoMove = false;
        map.setView([startLocation[0], startLocation[1]], 17);
    })

</script>